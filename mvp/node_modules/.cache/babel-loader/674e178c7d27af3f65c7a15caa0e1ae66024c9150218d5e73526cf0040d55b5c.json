{"ast":null,"code":"function _array_like_to_array(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _array_with_holes(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _class_call_check(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return !!right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\nfunction _iterable_to_array_limit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _non_iterable_rest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(arr, i) {\n  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _type_of(obj) {\n  \"@swc/helpers - typeof\";\n\n  return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nvar __typeError = function (msg) {\n  throw TypeError(msg);\n};\nvar __accessCheck = function (obj, member, msg) {\n  return member.has(obj) || __typeError(\"Cannot \" + msg);\n};\nvar __privateGet = function (obj, member, getter) {\n  return __accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = function (obj, member, value) {\n  return member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : _instanceof(member, WeakSet) ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = function (obj, member, value, setter) {\n  return __accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value;\n};\n// src/index.ts\nvar to_string = function (obj) {\n  return Object.prototype.toString.call(obj);\n};\nvar is_typed_array = function (value) {\n  return ArrayBuffer.isView(value) && !_instanceof(value, DataView);\n};\nvar is_date = function (obj) {\n  return to_string(obj) === \"[object Date]\";\n};\nvar is_regexp = function (obj) {\n  return to_string(obj) === \"[object RegExp]\";\n};\nvar is_error = function (obj) {\n  return to_string(obj) === \"[object Error]\";\n};\nvar is_boolean = function (obj) {\n  return to_string(obj) === \"[object Boolean]\";\n};\nvar is_number = function (obj) {\n  return to_string(obj) === \"[object Number]\";\n};\nvar is_string = function (obj) {\n  return to_string(obj) === \"[object String]\";\n};\nvar is_array = Array.isArray;\nvar gopd = Object.getOwnPropertyDescriptor;\nvar is_property_enumerable = Object.prototype.propertyIsEnumerable;\nvar get_own_property_symbols = Object.getOwnPropertySymbols;\nvar has_own_property = Object.prototype.hasOwnProperty;\nfunction own_enumerable_keys(obj) {\n  var res = Object.keys(obj);\n  var symbols = get_own_property_symbols(obj);\n  for (var i = 0; i < symbols.length; i++) {\n    if (is_property_enumerable.call(obj, symbols[i])) {\n      res.push(symbols[i]);\n    }\n  }\n  return res;\n}\nfunction is_writable(object, key) {\n  var _gopd;\n  return !((_gopd = gopd(object, key)) === null || _gopd === void 0 ? void 0 : _gopd.writable);\n}\nfunction copy(src, options) {\n  if ((typeof src === \"undefined\" ? \"undefined\" : _type_of(src)) === \"object\" && src !== null) {\n    var dst;\n    if (is_array(src)) {\n      dst = [];\n    } else if (is_date(src)) {\n      dst = new Date(src.getTime ? src.getTime() : src);\n    } else if (is_regexp(src)) {\n      dst = new RegExp(src);\n    } else if (is_error(src)) {\n      dst = {\n        message: src.message\n      };\n    } else if (is_boolean(src) || is_number(src) || is_string(src)) {\n      dst = Object(src);\n    } else if (is_typed_array(src)) {\n      return src.slice();\n    } else {\n      dst = Object.create(Object.getPrototypeOf(src));\n    }\n    var iterator_function = options.includeSymbols ? own_enumerable_keys : Object.keys;\n    var _iteratorNormalCompletion = true,\n      _didIteratorError = false,\n      _iteratorError = undefined;\n    try {\n      for (var _iterator = iterator_function(src)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var key = _step.value;\n        dst[key] = src[key];\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return dst;\n  }\n  return src;\n}\nvar empty_null = {\n  includeSymbols: false,\n  immutable: false\n};\nfunction walk(root, cb) {\n  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : empty_null;\n  var path = [];\n  var parents = [];\n  var alive = true;\n  var iterator_function = options.includeSymbols ? own_enumerable_keys : Object.keys;\n  var immutable = !!options.immutable;\n  return function walker(node_) {\n    var node = immutable ? copy(node_, options) : node_;\n    var modifiers = {};\n    var keep_going = true;\n    var state = {\n      node: node,\n      node_: node_,\n      path: [].concat(path),\n      parent: parents[parents.length - 1],\n      parents: parents,\n      key: path[path.length - 1],\n      isRoot: path.length === 0,\n      level: path.length,\n      circular: void 0,\n      isLeaf: false,\n      notLeaf: true,\n      notRoot: true,\n      isFirst: false,\n      isLast: false,\n      update: function update(x) {\n        var stopHere = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (!state.isRoot) {\n          state.parent.node[state.key] = x;\n        }\n        state.node = x;\n        if (stopHere) {\n          keep_going = false;\n        }\n      },\n      delete: function _delete(stopHere) {\n        delete state.parent.node[state.key];\n        if (stopHere) {\n          keep_going = false;\n        }\n      },\n      remove: function remove(stopHere) {\n        if (is_array(state.parent.node)) {\n          state.parent.node.splice(state.key, 1);\n        } else {\n          delete state.parent.node[state.key];\n        }\n        if (stopHere) {\n          keep_going = false;\n        }\n      },\n      keys: null,\n      before: function before(f) {\n        modifiers.before = f;\n      },\n      after: function after(f) {\n        modifiers.after = f;\n      },\n      pre: function pre(f) {\n        modifiers.pre = f;\n      },\n      post: function post(f) {\n        modifiers.post = f;\n      },\n      stop: function stop() {\n        alive = false;\n      },\n      block: function block() {\n        keep_going = false;\n      }\n    };\n    if (!alive) {\n      return state;\n    }\n    function update_state() {\n      if (_type_of(state.node) === \"object\" && state.node !== null) {\n        if (!state.keys || state.node_ !== state.node) {\n          state.keys = iterator_function(state.node);\n        }\n        state.isLeaf = state.keys.length === 0;\n        for (var i = 0; i < parents.length; i++) {\n          if (parents[i].node_ === node_) {\n            state.circular = parents[i];\n            break;\n          }\n        }\n      } else {\n        state.isLeaf = true;\n        state.keys = null;\n      }\n      state.notLeaf = !state.isLeaf;\n      state.notRoot = !state.isRoot;\n    }\n    update_state();\n    var ret = cb.call(state, state.node);\n    if (ret !== void 0 && state.update) {\n      state.update(ret);\n    }\n    if (modifiers.before) {\n      modifiers.before.call(state, state.node);\n    }\n    if (!keep_going) {\n      return state;\n    }\n    if (_type_of(state.node) === \"object\" && state.node !== null && !state.circular) {\n      parents.push(state);\n      update_state();\n      var _state_keys;\n      var _iteratorNormalCompletion = true,\n        _didIteratorError = false,\n        _iteratorError = undefined;\n      try {\n        for (var _iterator = Object.entries((_state_keys = state.keys) !== null && _state_keys !== void 0 ? _state_keys : [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step_value = _sliced_to_array(_step.value, 2),\n            index = _step_value[0],\n            key = _step_value[1];\n          var _state_keys1;\n          path.push(key);\n          if (modifiers.pre) {\n            modifiers.pre.call(state, state.node[key], key);\n          }\n          var child = walker(state.node[key]);\n          if (immutable && has_own_property.call(state.node, key) && !is_writable(state.node, key)) {\n            state.node[key] = child.node;\n          }\n          child.isLast = ((_state_keys1 = state.keys) === null || _state_keys1 === void 0 ? void 0 : _state_keys1.length) ? +index === state.keys.length - 1 : false;\n          child.isFirst = +index === 0;\n          if (modifiers.post) {\n            modifiers.post.call(state, child);\n          }\n          path.pop();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      parents.pop();\n    }\n    if (modifiers.after) {\n      modifiers.after.call(state, state.node);\n    }\n    return state;\n  }(root).node;\n}\nvar _value, _options;\nvar Traverse = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Traverse(obj) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : empty_null;\n    _class_call_check(this, Traverse);\n    // ! Have to keep these public as legacy mode requires them\n    __privateAdd(this, _value);\n    __privateAdd(this, _options);\n    __privateSet(this, _value, obj);\n    __privateSet(this, _options, options);\n  }\n  _create_class(Traverse, [{\n    /**\n    * Get the element at the array `path`.\n    */\n    key: \"get\",\n    value: function get(paths) {\n      var node = __privateGet(this, _value);\n      for (var i = 0; node && i < paths.length; i++) {\n        var key = paths[i];\n        if (!has_own_property.call(node, key) || !__privateGet(this, _options).includeSymbols && (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) === \"symbol\") {\n          return void 0;\n        }\n        node = node[key];\n      }\n      return node;\n    }\n  }, {\n    /**\n    * Return whether the element at the array `path` exists.\n    */\n    key: \"has\",\n    value: function has(paths) {\n      var node = __privateGet(this, _value);\n      for (var i = 0; node && i < paths.length; i++) {\n        var key = paths[i];\n        if (!has_own_property.call(node, key) || !__privateGet(this, _options).includeSymbols && (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) === \"symbol\") {\n          return false;\n        }\n        node = node[key];\n      }\n      return true;\n    }\n  }, {\n    /**\n    * Set the element at the array `path` to `value`.\n    */\n    key: \"set\",\n    value: function set(path, value) {\n      var node = __privateGet(this, _value);\n      var i = 0;\n      for (i = 0; i < path.length - 1; i++) {\n        var key = path[i];\n        if (!has_own_property.call(node, key)) {\n          node[key] = {};\n        }\n        node = node[key];\n      }\n      node[path[i]] = value;\n      return value;\n    }\n  }, {\n    /**\n    * Execute `fn` for each node in the object and return a new object with the results of the walk. To update nodes in the result use `this.update(value)`.\n    */\n    key: \"map\",\n    value: function map(cb) {\n      return walk(__privateGet(this, _value), cb, {\n        immutable: true,\n        includeSymbols: !!__privateGet(this, _options).includeSymbols\n      });\n    }\n  }, {\n    /**\n    * Execute `fn` for each node in the object but unlike `.map()`, when `this.update()` is called it updates the object in-place.\n    */\n    key: \"forEach\",\n    value: function forEach(cb) {\n      __privateSet(this, _value, walk(__privateGet(this, _value), cb, __privateGet(this, _options)));\n      return __privateGet(this, _value);\n    }\n  }, {\n    /**\n    * For each node in the object, perform a [left-fold](http://en.wikipedia.org/wiki/Fold_(higher-order_function)) with the return value of `fn(acc, node)`.\n    *\n    * If `init` isn't specified, `init` is set to the root object for the first step and the root element is skipped.\n    */\n    key: \"reduce\",\n    value: function reduce(cb, init) {\n      var skip = arguments.length === 1;\n      var acc = skip ? __privateGet(this, _value) : init;\n      this.forEach(function (x) {\n        if (!this.isRoot || !skip) {\n          acc = cb.call(this, acc, x);\n        }\n      });\n      return acc;\n    }\n  }, {\n    /**\n    * Return an `Array` of every possible non-cyclic path in the object.\n    * Paths are `Array`s of string keys.\n    */\n    key: \"paths\",\n    value: function paths() {\n      var acc = [];\n      this.forEach(function () {\n        acc.push(this.path);\n      });\n      return acc;\n    }\n  }, {\n    /**\n    * Return an `Array` of every node in the object.\n    */\n    key: \"nodes\",\n    value: function nodes() {\n      var acc = [];\n      this.forEach(function () {\n        acc.push(this.node);\n      });\n      return acc;\n    }\n  }, {\n    /**\n    * Create a deep clone of the object.\n    */\n    key: \"clone\",\n    value: function clone() {\n      var parents = [];\n      var nodes = [];\n      var options = __privateGet(this, _options);\n      if (is_typed_array(__privateGet(this, _value))) {\n        return __privateGet(this, _value).slice();\n      }\n      return function clone(src) {\n        for (var i = 0; i < parents.length; i++) {\n          if (parents[i] === src) {\n            return nodes[i];\n          }\n        }\n        if ((typeof src === \"undefined\" ? \"undefined\" : _type_of(src)) === \"object\" && src !== null) {\n          var dst = copy(src, options);\n          parents.push(src);\n          nodes.push(dst);\n          var iteratorFunction = options.includeSymbols ? own_enumerable_keys : Object.keys;\n          var _iteratorNormalCompletion = true,\n            _didIteratorError = false,\n            _iteratorError = undefined;\n          try {\n            for (var _iterator = iteratorFunction(src)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var key = _step.value;\n              dst[key] = clone(src[key]);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n          parents.pop();\n          nodes.pop();\n          return dst;\n        }\n        return src;\n      }(__privateGet(this, _value));\n    }\n  }]);\n  return Traverse;\n}();\n_value = new WeakMap();\n_options = new WeakMap();\nvar traverse = function (obj, options) {\n  return new Traverse(obj, options);\n};\ntraverse.get = function (obj, paths, options) {\n  return new Traverse(obj, options).get(paths);\n};\ntraverse.set = function (obj, path, value, options) {\n  return new Traverse(obj, options).set(path, value);\n};\ntraverse.has = function (obj, paths, options) {\n  return new Traverse(obj, options).has(paths);\n};\ntraverse.map = function (obj, cb, options) {\n  return new Traverse(obj, options).map(cb);\n};\ntraverse.forEach = function (obj, cb, options) {\n  return new Traverse(obj, options).forEach(cb);\n};\ntraverse.reduce = function (obj, cb, init, options) {\n  return new Traverse(obj, options).reduce(cb, init);\n};\ntraverse.paths = function (obj, options) {\n  return new Traverse(obj, options).paths();\n};\ntraverse.nodes = function (obj, options) {\n  return new Traverse(obj, options).nodes();\n};\ntraverse.clone = function (obj, options) {\n  return new Traverse(obj, options).clone();\n};\nvar src_default = traverse;\n// src/legacy.cts\n\nexport { src_default as default };","map":{"version":3,"names":["_array_like_to_array","arr","len","length","i","arr2","Array","_array_with_holes","isArray","_class_call_check","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_create_class","protoProps","staticProps","prototype","_instanceof","left","right","Symbol","hasInstance","_iterable_to_array_limit","_i","iterator","_arr","_n","_d","_s","_e","call","next","done","push","value","err","_non_iterable_rest","_sliced_to_array","_unsupported_iterable_to_array","_type_of","obj","constructor","o","minLen","n","toString","slice","name","from","test","__typeError","msg","__accessCheck","member","has","__privateGet","getter","get","__privateAdd","WeakSet","add","set","__privateSet","setter","to_string","is_typed_array","ArrayBuffer","isView","DataView","is_date","is_regexp","is_error","is_boolean","is_number","is_string","is_array","gopd","getOwnPropertyDescriptor","is_property_enumerable","propertyIsEnumerable","get_own_property_symbols","getOwnPropertySymbols","has_own_property","hasOwnProperty","own_enumerable_keys","res","keys","symbols","is_writable","object","_gopd","copy","src","options","dst","Date","getTime","RegExp","message","create","getPrototypeOf","iterator_function","includeSymbols","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","return","empty_null","immutable","walk","root","cb","arguments","path","parents","alive","walker","node_","node","modifiers","keep_going","state","concat","parent","isRoot","level","circular","isLeaf","notLeaf","notRoot","isFirst","isLast","update","x","stopHere","delete","_delete","remove","splice","before","f","after","pre","post","stop","block","update_state","ret","_state_keys","entries","_step_value","index","_state_keys1","child","pop","_value","_options","Traverse","paths","map","forEach","reduce","init","skip","acc","nodes","clone","iteratorFunction","WeakMap","traverse","src_default","default"],"sources":["D:/Vasya/Documents/STUDYING/NSU/4_year/ТехДок/Проект/anakot/node_modules/neotraverse/dist/legacy/legacy.mjs"],"sourcesContent":["function _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nvar __typeError = function(msg) {\n    throw TypeError(msg);\n};\nvar __accessCheck = function(obj, member, msg) {\n    return member.has(obj) || __typeError(\"Cannot \" + msg);\n};\nvar __privateGet = function(obj, member, getter) {\n    return __accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = function(obj, member, value) {\n    return member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : _instanceof(member, WeakSet) ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = function(obj, member, value, setter) {\n    return __accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value;\n};\n// src/index.ts\nvar to_string = function(obj) {\n    return Object.prototype.toString.call(obj);\n};\nvar is_typed_array = function(value) {\n    return ArrayBuffer.isView(value) && !_instanceof(value, DataView);\n};\nvar is_date = function(obj) {\n    return to_string(obj) === \"[object Date]\";\n};\nvar is_regexp = function(obj) {\n    return to_string(obj) === \"[object RegExp]\";\n};\nvar is_error = function(obj) {\n    return to_string(obj) === \"[object Error]\";\n};\nvar is_boolean = function(obj) {\n    return to_string(obj) === \"[object Boolean]\";\n};\nvar is_number = function(obj) {\n    return to_string(obj) === \"[object Number]\";\n};\nvar is_string = function(obj) {\n    return to_string(obj) === \"[object String]\";\n};\nvar is_array = Array.isArray;\nvar gopd = Object.getOwnPropertyDescriptor;\nvar is_property_enumerable = Object.prototype.propertyIsEnumerable;\nvar get_own_property_symbols = Object.getOwnPropertySymbols;\nvar has_own_property = Object.prototype.hasOwnProperty;\nfunction own_enumerable_keys(obj) {\n    var res = Object.keys(obj);\n    var symbols = get_own_property_symbols(obj);\n    for(var i = 0; i < symbols.length; i++){\n        if (is_property_enumerable.call(obj, symbols[i])) {\n            res.push(symbols[i]);\n        }\n    }\n    return res;\n}\nfunction is_writable(object, key) {\n    var _gopd;\n    return !((_gopd = gopd(object, key)) === null || _gopd === void 0 ? void 0 : _gopd.writable);\n}\nfunction copy(src, options) {\n    if ((typeof src === \"undefined\" ? \"undefined\" : _type_of(src)) === \"object\" && src !== null) {\n        var dst;\n        if (is_array(src)) {\n            dst = [];\n        } else if (is_date(src)) {\n            dst = new Date(src.getTime ? src.getTime() : src);\n        } else if (is_regexp(src)) {\n            dst = new RegExp(src);\n        } else if (is_error(src)) {\n            dst = {\n                message: src.message\n            };\n        } else if (is_boolean(src) || is_number(src) || is_string(src)) {\n            dst = Object(src);\n        } else if (is_typed_array(src)) {\n            return src.slice();\n        } else {\n            dst = Object.create(Object.getPrototypeOf(src));\n        }\n        var iterator_function = options.includeSymbols ? own_enumerable_keys : Object.keys;\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = iterator_function(src)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var key = _step.value;\n                dst[key] = src[key];\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        return dst;\n    }\n    return src;\n}\nvar empty_null = {\n    includeSymbols: false,\n    immutable: false\n};\nfunction walk(root, cb) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : empty_null;\n    var path = [];\n    var parents = [];\n    var alive = true;\n    var iterator_function = options.includeSymbols ? own_enumerable_keys : Object.keys;\n    var immutable = !!options.immutable;\n    return function walker(node_) {\n        var node = immutable ? copy(node_, options) : node_;\n        var modifiers = {};\n        var keep_going = true;\n        var state = {\n            node: node,\n            node_: node_,\n            path: [].concat(path),\n            parent: parents[parents.length - 1],\n            parents: parents,\n            key: path[path.length - 1],\n            isRoot: path.length === 0,\n            level: path.length,\n            circular: void 0,\n            isLeaf: false,\n            notLeaf: true,\n            notRoot: true,\n            isFirst: false,\n            isLast: false,\n            update: function update(x) {\n                var stopHere = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n                if (!state.isRoot) {\n                    state.parent.node[state.key] = x;\n                }\n                state.node = x;\n                if (stopHere) {\n                    keep_going = false;\n                }\n            },\n            delete: function _delete(stopHere) {\n                delete state.parent.node[state.key];\n                if (stopHere) {\n                    keep_going = false;\n                }\n            },\n            remove: function remove(stopHere) {\n                if (is_array(state.parent.node)) {\n                    state.parent.node.splice(state.key, 1);\n                } else {\n                    delete state.parent.node[state.key];\n                }\n                if (stopHere) {\n                    keep_going = false;\n                }\n            },\n            keys: null,\n            before: function before(f) {\n                modifiers.before = f;\n            },\n            after: function after(f) {\n                modifiers.after = f;\n            },\n            pre: function pre(f) {\n                modifiers.pre = f;\n            },\n            post: function post(f) {\n                modifiers.post = f;\n            },\n            stop: function stop() {\n                alive = false;\n            },\n            block: function block() {\n                keep_going = false;\n            }\n        };\n        if (!alive) {\n            return state;\n        }\n        function update_state() {\n            if (_type_of(state.node) === \"object\" && state.node !== null) {\n                if (!state.keys || state.node_ !== state.node) {\n                    state.keys = iterator_function(state.node);\n                }\n                state.isLeaf = state.keys.length === 0;\n                for(var i = 0; i < parents.length; i++){\n                    if (parents[i].node_ === node_) {\n                        state.circular = parents[i];\n                        break;\n                    }\n                }\n            } else {\n                state.isLeaf = true;\n                state.keys = null;\n            }\n            state.notLeaf = !state.isLeaf;\n            state.notRoot = !state.isRoot;\n        }\n        update_state();\n        var ret = cb.call(state, state.node);\n        if (ret !== void 0 && state.update) {\n            state.update(ret);\n        }\n        if (modifiers.before) {\n            modifiers.before.call(state, state.node);\n        }\n        if (!keep_going) {\n            return state;\n        }\n        if (_type_of(state.node) === \"object\" && state.node !== null && !state.circular) {\n            parents.push(state);\n            update_state();\n            var _state_keys;\n            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n            try {\n                for(var _iterator = Object.entries((_state_keys = state.keys) !== null && _state_keys !== void 0 ? _state_keys : [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                    var _step_value = _sliced_to_array(_step.value, 2), index = _step_value[0], key = _step_value[1];\n                    var _state_keys1;\n                    path.push(key);\n                    if (modifiers.pre) {\n                        modifiers.pre.call(state, state.node[key], key);\n                    }\n                    var child = walker(state.node[key]);\n                    if (immutable && has_own_property.call(state.node, key) && !is_writable(state.node, key)) {\n                        state.node[key] = child.node;\n                    }\n                    child.isLast = ((_state_keys1 = state.keys) === null || _state_keys1 === void 0 ? void 0 : _state_keys1.length) ? +index === state.keys.length - 1 : false;\n                    child.isFirst = +index === 0;\n                    if (modifiers.post) {\n                        modifiers.post.call(state, child);\n                    }\n                    path.pop();\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return != null) {\n                        _iterator.return();\n                    }\n                } finally{\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n            parents.pop();\n        }\n        if (modifiers.after) {\n            modifiers.after.call(state, state.node);\n        }\n        return state;\n    }(root).node;\n}\nvar _value, _options;\nvar Traverse = /*#__PURE__*/ function() {\n    \"use strict\";\n    function Traverse(obj) {\n        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : empty_null;\n        _class_call_check(this, Traverse);\n        // ! Have to keep these public as legacy mode requires them\n        __privateAdd(this, _value);\n        __privateAdd(this, _options);\n        __privateSet(this, _value, obj);\n        __privateSet(this, _options, options);\n    }\n    _create_class(Traverse, [\n        {\n            /**\n   * Get the element at the array `path`.\n   */ key: \"get\",\n            value: function get(paths) {\n                var node = __privateGet(this, _value);\n                for(var i = 0; node && i < paths.length; i++){\n                    var key = paths[i];\n                    if (!has_own_property.call(node, key) || !__privateGet(this, _options).includeSymbols && (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) === \"symbol\") {\n                        return void 0;\n                    }\n                    node = node[key];\n                }\n                return node;\n            }\n        },\n        {\n            /**\n   * Return whether the element at the array `path` exists.\n   */ key: \"has\",\n            value: function has(paths) {\n                var node = __privateGet(this, _value);\n                for(var i = 0; node && i < paths.length; i++){\n                    var key = paths[i];\n                    if (!has_own_property.call(node, key) || !__privateGet(this, _options).includeSymbols && (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) === \"symbol\") {\n                        return false;\n                    }\n                    node = node[key];\n                }\n                return true;\n            }\n        },\n        {\n            /**\n   * Set the element at the array `path` to `value`.\n   */ key: \"set\",\n            value: function set(path, value) {\n                var node = __privateGet(this, _value);\n                var i = 0;\n                for(i = 0; i < path.length - 1; i++){\n                    var key = path[i];\n                    if (!has_own_property.call(node, key)) {\n                        node[key] = {};\n                    }\n                    node = node[key];\n                }\n                node[path[i]] = value;\n                return value;\n            }\n        },\n        {\n            /**\n   * Execute `fn` for each node in the object and return a new object with the results of the walk. To update nodes in the result use `this.update(value)`.\n   */ key: \"map\",\n            value: function map(cb) {\n                return walk(__privateGet(this, _value), cb, {\n                    immutable: true,\n                    includeSymbols: !!__privateGet(this, _options).includeSymbols\n                });\n            }\n        },\n        {\n            /**\n   * Execute `fn` for each node in the object but unlike `.map()`, when `this.update()` is called it updates the object in-place.\n   */ key: \"forEach\",\n            value: function forEach(cb) {\n                __privateSet(this, _value, walk(__privateGet(this, _value), cb, __privateGet(this, _options)));\n                return __privateGet(this, _value);\n            }\n        },\n        {\n            /**\n   * For each node in the object, perform a [left-fold](http://en.wikipedia.org/wiki/Fold_(higher-order_function)) with the return value of `fn(acc, node)`.\n   *\n   * If `init` isn't specified, `init` is set to the root object for the first step and the root element is skipped.\n   */ key: \"reduce\",\n            value: function reduce(cb, init) {\n                var skip = arguments.length === 1;\n                var acc = skip ? __privateGet(this, _value) : init;\n                this.forEach(function(x) {\n                    if (!this.isRoot || !skip) {\n                        acc = cb.call(this, acc, x);\n                    }\n                });\n                return acc;\n            }\n        },\n        {\n            /**\n   * Return an `Array` of every possible non-cyclic path in the object.\n   * Paths are `Array`s of string keys.\n   */ key: \"paths\",\n            value: function paths() {\n                var acc = [];\n                this.forEach(function() {\n                    acc.push(this.path);\n                });\n                return acc;\n            }\n        },\n        {\n            /**\n   * Return an `Array` of every node in the object.\n   */ key: \"nodes\",\n            value: function nodes() {\n                var acc = [];\n                this.forEach(function() {\n                    acc.push(this.node);\n                });\n                return acc;\n            }\n        },\n        {\n            /**\n   * Create a deep clone of the object.\n   */ key: \"clone\",\n            value: function clone() {\n                var parents = [];\n                var nodes = [];\n                var options = __privateGet(this, _options);\n                if (is_typed_array(__privateGet(this, _value))) {\n                    return __privateGet(this, _value).slice();\n                }\n                return function clone(src) {\n                    for(var i = 0; i < parents.length; i++){\n                        if (parents[i] === src) {\n                            return nodes[i];\n                        }\n                    }\n                    if ((typeof src === \"undefined\" ? \"undefined\" : _type_of(src)) === \"object\" && src !== null) {\n                        var dst = copy(src, options);\n                        parents.push(src);\n                        nodes.push(dst);\n                        var iteratorFunction = options.includeSymbols ? own_enumerable_keys : Object.keys;\n                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                        try {\n                            for(var _iterator = iteratorFunction(src)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                                var key = _step.value;\n                                dst[key] = clone(src[key]);\n                            }\n                        } catch (err) {\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                        } finally{\n                            try {\n                                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                                    _iterator.return();\n                                }\n                            } finally{\n                                if (_didIteratorError) {\n                                    throw _iteratorError;\n                                }\n                            }\n                        }\n                        parents.pop();\n                        nodes.pop();\n                        return dst;\n                    }\n                    return src;\n                }(__privateGet(this, _value));\n            }\n        }\n    ]);\n    return Traverse;\n}();\n_value = new WeakMap();\n_options = new WeakMap();\nvar traverse = function(obj, options) {\n    return new Traverse(obj, options);\n};\ntraverse.get = function(obj, paths, options) {\n    return new Traverse(obj, options).get(paths);\n};\ntraverse.set = function(obj, path, value, options) {\n    return new Traverse(obj, options).set(path, value);\n};\ntraverse.has = function(obj, paths, options) {\n    return new Traverse(obj, options).has(paths);\n};\ntraverse.map = function(obj, cb, options) {\n    return new Traverse(obj, options).map(cb);\n};\ntraverse.forEach = function(obj, cb, options) {\n    return new Traverse(obj, options).forEach(cb);\n};\ntraverse.reduce = function(obj, cb, init, options) {\n    return new Traverse(obj, options).reduce(cb, init);\n};\ntraverse.paths = function(obj, options) {\n    return new Traverse(obj, options).paths();\n};\ntraverse.nodes = function(obj, options) {\n    return new Traverse(obj, options).nodes();\n};\ntraverse.clone = function(obj, options) {\n    return new Traverse(obj, options).clone();\n};\nvar src_default = traverse;\n// src/legacy.cts\n\nexport { src_default as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}