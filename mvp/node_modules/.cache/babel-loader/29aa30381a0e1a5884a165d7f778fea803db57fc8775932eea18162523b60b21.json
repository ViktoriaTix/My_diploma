{"ast":null,"code":"import mapSpec, { plugins } from '../../specmap/index.js';\nimport { makeFetchJSON } from '../../utils/index.js';\nimport * as optionsUtil from '../../utils/options.js';\nexport default async function resolveGenericStrategy(options) {\n  const {\n    spec,\n    mode,\n    allowMetaPatches = true,\n    pathDiscriminator,\n    modelPropertyMacro,\n    parameterMacro,\n    requestInterceptor,\n    responseInterceptor,\n    skipNormalization = false,\n    useCircularStructures,\n    strategies\n  } = options;\n  const retrievalURI = optionsUtil.retrievalURI(options);\n  const httpClient = optionsUtil.httpClient(options);\n  const strategy = strategies.find(strg => strg.match(spec));\n  return doResolve(spec);\n  async function doResolve(_spec) {\n    if (retrievalURI) {\n      plugins.refs.docCache[retrievalURI] = _spec;\n    }\n\n    // Build a json-fetcher ( ie: give it a URL and get json out )\n    plugins.refs.fetchJSON = makeFetchJSON(httpClient, {\n      requestInterceptor,\n      responseInterceptor\n    });\n    const plugs = [plugins.refs];\n    if (typeof parameterMacro === 'function') {\n      plugs.push(plugins.parameters);\n    }\n    if (typeof modelPropertyMacro === 'function') {\n      plugs.push(plugins.properties);\n    }\n    if (mode !== 'strict') {\n      plugs.push(plugins.allOf);\n    }\n\n    // mapSpec is where the hard work happens\n    const result = await mapSpec({\n      spec: _spec,\n      context: {\n        baseDoc: retrievalURI\n      },\n      plugins: plugs,\n      allowMetaPatches,\n      // allows adding .meta patches, which include adding `$$ref`s to the spec\n      pathDiscriminator,\n      // for lazy resolution\n      parameterMacro,\n      modelPropertyMacro,\n      useCircularStructures\n    });\n    if (!skipNormalization) {\n      result.spec = strategy.normalize(result.spec);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["mapSpec","plugins","makeFetchJSON","optionsUtil","resolveGenericStrategy","options","spec","mode","allowMetaPatches","pathDiscriminator","modelPropertyMacro","parameterMacro","requestInterceptor","responseInterceptor","skipNormalization","useCircularStructures","strategies","retrievalURI","httpClient","strategy","find","strg","match","doResolve","_spec","refs","docCache","fetchJSON","plugs","push","parameters","properties","allOf","result","context","baseDoc","normalize"],"sources":["D:/Vasya/Documents/STUDYING/NSU/4_year/ТехДок/Проект/anakot/node_modules/swagger-client/es/resolver/strategies/generic/resolve.js"],"sourcesContent":["import mapSpec, { plugins } from '../../specmap/index.js';\nimport { makeFetchJSON } from '../../utils/index.js';\nimport * as optionsUtil from '../../utils/options.js';\nexport default async function resolveGenericStrategy(options) {\n  const {\n    spec,\n    mode,\n    allowMetaPatches = true,\n    pathDiscriminator,\n    modelPropertyMacro,\n    parameterMacro,\n    requestInterceptor,\n    responseInterceptor,\n    skipNormalization = false,\n    useCircularStructures,\n    strategies\n  } = options;\n  const retrievalURI = optionsUtil.retrievalURI(options);\n  const httpClient = optionsUtil.httpClient(options);\n  const strategy = strategies.find(strg => strg.match(spec));\n  return doResolve(spec);\n  async function doResolve(_spec) {\n    if (retrievalURI) {\n      plugins.refs.docCache[retrievalURI] = _spec;\n    }\n\n    // Build a json-fetcher ( ie: give it a URL and get json out )\n    plugins.refs.fetchJSON = makeFetchJSON(httpClient, {\n      requestInterceptor,\n      responseInterceptor\n    });\n    const plugs = [plugins.refs];\n    if (typeof parameterMacro === 'function') {\n      plugs.push(plugins.parameters);\n    }\n    if (typeof modelPropertyMacro === 'function') {\n      plugs.push(plugins.properties);\n    }\n    if (mode !== 'strict') {\n      plugs.push(plugins.allOf);\n    }\n\n    // mapSpec is where the hard work happens\n    const result = await mapSpec({\n      spec: _spec,\n      context: {\n        baseDoc: retrievalURI\n      },\n      plugins: plugs,\n      allowMetaPatches,\n      // allows adding .meta patches, which include adding `$$ref`s to the spec\n      pathDiscriminator,\n      // for lazy resolution\n      parameterMacro,\n      modelPropertyMacro,\n      useCircularStructures\n    });\n    if (!skipNormalization) {\n      result.spec = strategy.normalize(result.spec);\n    }\n    return result;\n  }\n}"],"mappings":"AAAA,OAAOA,OAAO,IAAIC,OAAO,QAAQ,wBAAwB;AACzD,SAASC,aAAa,QAAQ,sBAAsB;AACpD,OAAO,KAAKC,WAAW,MAAM,wBAAwB;AACrD,eAAe,eAAeC,sBAAsBA,CAACC,OAAO,EAAE;EAC5D,MAAM;IACJC,IAAI;IACJC,IAAI;IACJC,gBAAgB,GAAG,IAAI;IACvBC,iBAAiB;IACjBC,kBAAkB;IAClBC,cAAc;IACdC,kBAAkB;IAClBC,mBAAmB;IACnBC,iBAAiB,GAAG,KAAK;IACzBC,qBAAqB;IACrBC;EACF,CAAC,GAAGX,OAAO;EACX,MAAMY,YAAY,GAAGd,WAAW,CAACc,YAAY,CAACZ,OAAO,CAAC;EACtD,MAAMa,UAAU,GAAGf,WAAW,CAACe,UAAU,CAACb,OAAO,CAAC;EAClD,MAAMc,QAAQ,GAAGH,UAAU,CAACI,IAAI,CAACC,IAAI,IAAIA,IAAI,CAACC,KAAK,CAAChB,IAAI,CAAC,CAAC;EAC1D,OAAOiB,SAAS,CAACjB,IAAI,CAAC;EACtB,eAAeiB,SAASA,CAACC,KAAK,EAAE;IAC9B,IAAIP,YAAY,EAAE;MAChBhB,OAAO,CAACwB,IAAI,CAACC,QAAQ,CAACT,YAAY,CAAC,GAAGO,KAAK;IAC7C;;IAEA;IACAvB,OAAO,CAACwB,IAAI,CAACE,SAAS,GAAGzB,aAAa,CAACgB,UAAU,EAAE;MACjDN,kBAAkB;MAClBC;IACF,CAAC,CAAC;IACF,MAAMe,KAAK,GAAG,CAAC3B,OAAO,CAACwB,IAAI,CAAC;IAC5B,IAAI,OAAOd,cAAc,KAAK,UAAU,EAAE;MACxCiB,KAAK,CAACC,IAAI,CAAC5B,OAAO,CAAC6B,UAAU,CAAC;IAChC;IACA,IAAI,OAAOpB,kBAAkB,KAAK,UAAU,EAAE;MAC5CkB,KAAK,CAACC,IAAI,CAAC5B,OAAO,CAAC8B,UAAU,CAAC;IAChC;IACA,IAAIxB,IAAI,KAAK,QAAQ,EAAE;MACrBqB,KAAK,CAACC,IAAI,CAAC5B,OAAO,CAAC+B,KAAK,CAAC;IAC3B;;IAEA;IACA,MAAMC,MAAM,GAAG,MAAMjC,OAAO,CAAC;MAC3BM,IAAI,EAAEkB,KAAK;MACXU,OAAO,EAAE;QACPC,OAAO,EAAElB;MACX,CAAC;MACDhB,OAAO,EAAE2B,KAAK;MACdpB,gBAAgB;MAChB;MACAC,iBAAiB;MACjB;MACAE,cAAc;MACdD,kBAAkB;MAClBK;IACF,CAAC,CAAC;IACF,IAAI,CAACD,iBAAiB,EAAE;MACtBmB,MAAM,CAAC3B,IAAI,GAAGa,QAAQ,CAACiB,SAAS,CAACH,MAAM,CAAC3B,IAAI,CAAC;IAC/C;IACA,OAAO2B,MAAM;EACf;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}