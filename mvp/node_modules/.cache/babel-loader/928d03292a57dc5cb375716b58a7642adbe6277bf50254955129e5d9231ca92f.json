{"ast":null,"code":"import cookie from 'cookie';\nimport { identity } from 'ramda';\nimport { isPlainObject } from 'ramda-adjunct';\nimport { test as testServerURLTemplate, substitute as substituteServerURLTemplate } from 'openapi-server-url-templating';\nimport { ApiDOMStructuredError } from '@swagger-api/apidom-error';\nimport { url } from '@swagger-api/apidom-reference/configuration/empty';\nimport { DEFAULT_BASE_URL, DEFAULT_OPENAPI_3_SERVER } from '../constants.js';\nimport stockHttp from '../http/index.js';\nimport { serializeRequest } from '../http/serializers/request/index.js';\nimport SWAGGER2_PARAMETER_BUILDERS from './swagger2/parameter-builders.js';\nimport * as OAS3_PARAMETER_BUILDERS from './oas3/parameter-builders.js';\nimport oas3BuildRequest from './oas3/build-request.js';\nimport swagger2BuildRequest from './swagger2/build-request.js';\nimport { getOperationRaw, idFromPathMethodLegacy } from '../helpers/index.js';\nimport { isOpenAPI3 } from '../helpers/openapi-predicates.js';\nconst arrayOrEmpty = ar => Array.isArray(ar) ? ar : [];\n\n/**\n * `parseURIReference` function simulates the behavior of `node:url` parse function.\n * New WHATWG URL API is not capable of parsing relative references natively,\n * but can be adapter by utilizing the `base` parameter.\n */\nconst parseURIReference = uriReference => {\n  try {\n    return new URL(uriReference);\n  } catch {\n    const parsedURL = new URL(uriReference, DEFAULT_BASE_URL);\n    const pathname = String(uriReference).startsWith('/') ? parsedURL.pathname : parsedURL.pathname.substring(1);\n    return {\n      hash: parsedURL.hash,\n      host: '',\n      hostname: '',\n      href: '',\n      origin: '',\n      password: '',\n      pathname,\n      port: '',\n      protocol: '',\n      search: parsedURL.search,\n      searchParams: parsedURL.searchParams\n    };\n  }\n};\nclass OperationNotFoundError extends ApiDOMStructuredError {}\nconst findParametersWithName = (name, parameters) => parameters.filter(p => p.name === name);\n\n// removes parameters that have duplicate 'in' and 'name' properties\nconst deduplicateParameters = parameters => {\n  const paramsMap = {};\n  parameters.forEach(p => {\n    if (!paramsMap[p.in]) {\n      paramsMap[p.in] = {};\n    }\n    paramsMap[p.in][p.name] = p;\n  });\n  const dedupedParameters = [];\n  Object.keys(paramsMap).forEach(i => {\n    Object.keys(paramsMap[i]).forEach(p => {\n      dedupedParameters.push(paramsMap[i][p]);\n    });\n  });\n  return dedupedParameters;\n};\n\n// For stubbing in tests\nexport const self = {\n  buildRequest\n};\n\n// Execute request, with the given operationId and parameters\n// pathName/method or operationId is optional\nexport function execute({\n  http: userHttp,\n  fetch,\n  // This is legacy\n  spec,\n  operationId,\n  pathName,\n  method,\n  parameters,\n  securities,\n  ...extras\n}) {\n  // Provide default fetch implementation\n  const http = userHttp || fetch || stockHttp; // Default to _our_ http\n\n  if (pathName && method && !operationId) {\n    operationId = idFromPathMethodLegacy(pathName, method);\n  }\n  const request = self.buildRequest({\n    spec,\n    operationId,\n    parameters,\n    securities,\n    http,\n    ...extras\n  });\n  if (request.body && (isPlainObject(request.body) || Array.isArray(request.body))) {\n    request.body = JSON.stringify(request.body);\n  }\n\n  // Build request and execute it\n  return http(request);\n}\n\n// Build a request, which can be handled by the `http.js` implementation.\nexport function buildRequest(options) {\n  var _baseURL;\n  const {\n    spec,\n    operationId,\n    responseContentType,\n    scheme,\n    requestInterceptor,\n    responseInterceptor,\n    contextUrl,\n    userFetch,\n    server,\n    serverVariables,\n    http,\n    signal,\n    serverVariableEncoder\n  } = options;\n  let {\n    parameters,\n    parameterBuilders,\n    baseURL\n  } = options;\n  const specIsOAS3 = isOpenAPI3(spec);\n  if (!parameterBuilders) {\n    // user did not provide custom parameter builders\n    if (specIsOAS3) {\n      parameterBuilders = OAS3_PARAMETER_BUILDERS;\n    } else {\n      parameterBuilders = SWAGGER2_PARAMETER_BUILDERS;\n    }\n  }\n\n  // Set credentials with 'http.withCredentials' value\n  const credentials = http && http.withCredentials ? 'include' : 'same-origin';\n\n  // Base Template\n  let req = {\n    url: '',\n    credentials,\n    headers: {},\n    cookies: {}\n  };\n  if (signal) {\n    req.signal = signal;\n  }\n  if (requestInterceptor) {\n    req.requestInterceptor = requestInterceptor;\n  }\n  if (responseInterceptor) {\n    req.responseInterceptor = responseInterceptor;\n  }\n  if (userFetch) {\n    req.userFetch = userFetch;\n  }\n  const operationRaw = getOperationRaw(spec, operationId);\n  if (!operationRaw) {\n    throw new OperationNotFoundError(`Operation ${operationId} not found`);\n  }\n  const {\n    operation = {},\n    method,\n    pathName\n  } = operationRaw;\n  baseURL = (_baseURL = baseURL) !== null && _baseURL !== void 0 ? _baseURL : baseUrl({\n    spec,\n    scheme,\n    contextUrl,\n    server,\n    serverVariables,\n    pathName,\n    method,\n    serverVariableEncoder\n  });\n  req.url += baseURL;\n\n  // Mostly for testing\n  if (!operationId) {\n    // Not removing req.cookies causes testing issues and would\n    // change our interface, so we're always sure to remove it.\n    // See the same statement lower down in this function for\n    // more context.\n    delete req.cookies;\n    return req;\n  }\n  req.url += pathName; // Have not yet replaced the path parameters\n  req.method = `${method}`.toUpperCase();\n  parameters = parameters || {};\n  const path = spec.paths[pathName] || {};\n  if (responseContentType) {\n    req.headers.accept = responseContentType;\n  }\n  const combinedParameters = deduplicateParameters([].concat(arrayOrEmpty(operation.parameters)) // operation parameters\n  .concat(arrayOrEmpty(path.parameters))); // path parameters\n\n  // REVIEW: OAS3: have any key names or parameter shapes changed?\n  // Any new features that need to be plugged in here?\n\n  // Add values to request\n  combinedParameters.forEach(parameter => {\n    const builder = parameterBuilders[parameter.in];\n    let value;\n    if (parameter.in === 'body' && parameter.schema && parameter.schema.properties) {\n      value = parameters;\n    }\n    value = parameter && parameter.name && parameters[parameter.name];\n    if (typeof value === 'undefined') {\n      // check for `name-in` formatted key\n      value = parameter && parameter.name && parameters[`${parameter.in}.${parameter.name}`];\n    } else if (findParametersWithName(parameter.name, combinedParameters).length > 1) {\n      // value came from `parameters[parameter.name]`\n      // check to see if this is an ambiguous parameter\n      // eslint-disable-next-line no-console\n      console.warn(`Parameter '${parameter.name}' is ambiguous because the defined spec has more than one parameter with the name: '${parameter.name}' and the passed-in parameter values did not define an 'in' value.`);\n    }\n    if (value === null) {\n      return;\n    }\n    if (typeof parameter.default !== 'undefined' && typeof value === 'undefined') {\n      value = parameter.default;\n    }\n    if (typeof value === 'undefined' && parameter.required && !parameter.allowEmptyValue) {\n      throw new Error(`Required parameter ${parameter.name} is not provided`);\n    }\n    if (specIsOAS3 && parameter.schema && parameter.schema.type === 'object' && typeof value === 'string') {\n      try {\n        value = JSON.parse(value);\n      } catch (e) {\n        throw new Error('Could not parse object parameter value string as JSON');\n      }\n    }\n    if (builder) {\n      builder({\n        req,\n        parameter,\n        value,\n        operation,\n        spec,\n        baseURL\n      });\n    }\n  });\n\n  // Do version-specific tasks, then return those results.\n  const versionSpecificOptions = {\n    ...options,\n    operation\n  };\n  if (specIsOAS3) {\n    req = oas3BuildRequest(versionSpecificOptions, req);\n  } else {\n    // If not OAS3, then treat as Swagger2.\n    req = swagger2BuildRequest(versionSpecificOptions, req);\n  }\n\n  // If the cookie convenience object exists in our request,\n  // serialize its content and then delete the cookie object.\n  if (req.cookies && Object.keys(req.cookies).length) {\n    const cookieString = Object.keys(req.cookies).reduce((prev, cookieName) => {\n      const cookieValue = req.cookies[cookieName];\n      const prefix = prev ? '&' : '';\n      const stringified = cookie.serialize(cookieName, cookieValue);\n      return prev + prefix + stringified;\n    }, '');\n    req.headers.Cookie = cookieString;\n  }\n  if (req.cookies) {\n    // even if no cookies were defined, we need to remove\n    // the cookies key from our request, or many legacy\n    // tests will break.\n    delete req.cookies;\n  }\n\n  // Will add the query object into the URL, if it exists\n  // ... will also create a FormData instance, if multipart/form-data (eg: a file)\n  return serializeRequest(req);\n}\nconst stripNonAlpha = str => str ? str.replace(/\\W/g, '') : null;\n\n// be careful when modifying this! it is a publicly-exposed method.\nexport function baseUrl(obj) {\n  const specIsOAS3 = isOpenAPI3(obj.spec);\n  return specIsOAS3 ? oas3BaseUrl(obj) : swagger2BaseUrl(obj);\n}\nconst isNonEmptyServerList = value => Array.isArray(value) && value.length > 0;\nfunction oas3BaseUrl({\n  spec,\n  pathName,\n  method,\n  server,\n  contextUrl,\n  serverVariables = {},\n  serverVariableEncoder\n}) {\n  var _spec$paths, _spec$paths2;\n  let servers = [];\n  let selectedServerUrl = '';\n  let selectedServerObj;\n\n  // compute the servers (this will be taken care of by ApiDOM refrator plugins in future\n  const operationLevelServers = spec === null || spec === void 0 || (_spec$paths = spec.paths) === null || _spec$paths === void 0 || (_spec$paths = _spec$paths[pathName]) === null || _spec$paths === void 0 || (_spec$paths = _spec$paths[(method || '').toLowerCase()]) === null || _spec$paths === void 0 ? void 0 : _spec$paths.servers;\n  const pathItemLevelServers = spec === null || spec === void 0 || (_spec$paths2 = spec.paths) === null || _spec$paths2 === void 0 || (_spec$paths2 = _spec$paths2[pathName]) === null || _spec$paths2 === void 0 ? void 0 : _spec$paths2.servers;\n  const rootLevelServers = spec === null || spec === void 0 ? void 0 : spec.servers;\n  servers = isNonEmptyServerList(operationLevelServers) // eslint-disable-line no-nested-ternary\n  ? operationLevelServers : isNonEmptyServerList(pathItemLevelServers) // eslint-disable-line no-nested-ternary\n  ? pathItemLevelServers : isNonEmptyServerList(rootLevelServers) ? rootLevelServers : [DEFAULT_OPENAPI_3_SERVER];\n\n  // pick the first server that matches the server url\n  if (server) {\n    selectedServerObj = servers.find(srv => srv.url === server);\n    if (selectedServerObj) selectedServerUrl = server;\n  }\n\n  // default to the first server if we don't have one by now\n  if (!selectedServerUrl) {\n    [selectedServerObj] = servers;\n    selectedServerUrl = selectedServerObj.url;\n  }\n  if (testServerURLTemplate(selectedServerUrl, {\n    strict: true\n  })) {\n    const selectedServerVariables = Object.entries({\n      ...selectedServerObj.variables\n    }).reduce((acc, [serverVariableName, serverVariable]) => {\n      acc[serverVariableName] = serverVariable.default;\n      return acc;\n    }, {});\n    selectedServerUrl = substituteServerURLTemplate(selectedServerUrl, {\n      ...selectedServerVariables,\n      ...serverVariables\n    }, {\n      encoder: typeof serverVariableEncoder === 'function' ? serverVariableEncoder : identity\n    });\n  }\n  return buildOas3UrlWithContext(selectedServerUrl, contextUrl);\n}\nfunction buildOas3UrlWithContext(ourUrl = '', contextUrl = '') {\n  // relative server url should be resolved against contextUrl\n  const parsedUrl = ourUrl && contextUrl ? parseURIReference(url.resolve(contextUrl, ourUrl)) : parseURIReference(ourUrl);\n  const parsedContextUrl = parseURIReference(contextUrl);\n  const computedScheme = stripNonAlpha(parsedUrl.protocol) || stripNonAlpha(parsedContextUrl.protocol);\n  const computedHost = parsedUrl.host || parsedContextUrl.host;\n  const computedPath = parsedUrl.pathname;\n  let res;\n  if (computedScheme && computedHost) {\n    res = `${computedScheme}://${computedHost + computedPath}`;\n\n    // if last character is '/', trim it off\n  } else {\n    res = computedPath;\n  }\n  return res[res.length - 1] === '/' ? res.slice(0, -1) : res;\n}\n\n// Compose the baseUrl ( scheme + host + basePath )\nfunction swagger2BaseUrl({\n  spec,\n  scheme,\n  contextUrl = ''\n}) {\n  const parsedContextUrl = parseURIReference(contextUrl);\n  const firstSchemeInSpec = Array.isArray(spec.schemes) ? spec.schemes[0] : null;\n  const computedScheme = scheme || firstSchemeInSpec || stripNonAlpha(parsedContextUrl.protocol) || 'http';\n  const computedHost = spec.host || parsedContextUrl.host || '';\n  const computedPath = spec.basePath || '';\n  let res;\n  if (computedScheme && computedHost) {\n    // we have what we need for an absolute URL\n    res = `${computedScheme}://${computedHost + computedPath}`;\n  } else {\n    // if not, a relative URL will have to do\n    res = computedPath;\n  }\n\n  // If last character is '/', trim it off\n  return res[res.length - 1] === '/' ? res.slice(0, -1) : res;\n}","map":{"version":3,"names":["cookie","identity","isPlainObject","test","testServerURLTemplate","substitute","substituteServerURLTemplate","ApiDOMStructuredError","url","DEFAULT_BASE_URL","DEFAULT_OPENAPI_3_SERVER","stockHttp","serializeRequest","SWAGGER2_PARAMETER_BUILDERS","OAS3_PARAMETER_BUILDERS","oas3BuildRequest","swagger2BuildRequest","getOperationRaw","idFromPathMethodLegacy","isOpenAPI3","arrayOrEmpty","ar","Array","isArray","parseURIReference","uriReference","URL","parsedURL","pathname","String","startsWith","substring","hash","host","hostname","href","origin","password","port","protocol","search","searchParams","OperationNotFoundError","findParametersWithName","name","parameters","filter","p","deduplicateParameters","paramsMap","forEach","in","dedupedParameters","Object","keys","i","push","self","buildRequest","execute","http","userHttp","fetch","spec","operationId","pathName","method","securities","extras","request","body","JSON","stringify","options","_baseURL","responseContentType","scheme","requestInterceptor","responseInterceptor","contextUrl","userFetch","server","serverVariables","signal","serverVariableEncoder","parameterBuilders","baseURL","specIsOAS3","credentials","withCredentials","req","headers","cookies","operationRaw","operation","baseUrl","toUpperCase","path","paths","accept","combinedParameters","concat","parameter","builder","value","schema","properties","length","console","warn","default","required","allowEmptyValue","Error","type","parse","e","versionSpecificOptions","cookieString","reduce","prev","cookieName","cookieValue","prefix","stringified","serialize","Cookie","stripNonAlpha","str","replace","obj","oas3BaseUrl","swagger2BaseUrl","isNonEmptyServerList","_spec$paths","_spec$paths2","servers","selectedServerUrl","selectedServerObj","operationLevelServers","toLowerCase","pathItemLevelServers","rootLevelServers","find","srv","strict","selectedServerVariables","entries","variables","acc","serverVariableName","serverVariable","encoder","buildOas3UrlWithContext","ourUrl","parsedUrl","resolve","parsedContextUrl","computedScheme","computedHost","computedPath","res","slice","firstSchemeInSpec","schemes","basePath"],"sources":["D:/Vasya/Documents/STUDYING/NSU/4_year/ТехДок/Проект/anakot/node_modules/swagger-client/es/execute/index.js"],"sourcesContent":["import cookie from 'cookie';\nimport { identity } from 'ramda';\nimport { isPlainObject } from 'ramda-adjunct';\nimport { test as testServerURLTemplate, substitute as substituteServerURLTemplate } from 'openapi-server-url-templating';\nimport { ApiDOMStructuredError } from '@swagger-api/apidom-error';\nimport { url } from '@swagger-api/apidom-reference/configuration/empty';\nimport { DEFAULT_BASE_URL, DEFAULT_OPENAPI_3_SERVER } from '../constants.js';\nimport stockHttp from '../http/index.js';\nimport { serializeRequest } from '../http/serializers/request/index.js';\nimport SWAGGER2_PARAMETER_BUILDERS from './swagger2/parameter-builders.js';\nimport * as OAS3_PARAMETER_BUILDERS from './oas3/parameter-builders.js';\nimport oas3BuildRequest from './oas3/build-request.js';\nimport swagger2BuildRequest from './swagger2/build-request.js';\nimport { getOperationRaw, idFromPathMethodLegacy } from '../helpers/index.js';\nimport { isOpenAPI3 } from '../helpers/openapi-predicates.js';\nconst arrayOrEmpty = ar => Array.isArray(ar) ? ar : [];\n\n/**\n * `parseURIReference` function simulates the behavior of `node:url` parse function.\n * New WHATWG URL API is not capable of parsing relative references natively,\n * but can be adapter by utilizing the `base` parameter.\n */\nconst parseURIReference = uriReference => {\n  try {\n    return new URL(uriReference);\n  } catch {\n    const parsedURL = new URL(uriReference, DEFAULT_BASE_URL);\n    const pathname = String(uriReference).startsWith('/') ? parsedURL.pathname : parsedURL.pathname.substring(1);\n    return {\n      hash: parsedURL.hash,\n      host: '',\n      hostname: '',\n      href: '',\n      origin: '',\n      password: '',\n      pathname,\n      port: '',\n      protocol: '',\n      search: parsedURL.search,\n      searchParams: parsedURL.searchParams\n    };\n  }\n};\nclass OperationNotFoundError extends ApiDOMStructuredError {}\nconst findParametersWithName = (name, parameters) => parameters.filter(p => p.name === name);\n\n// removes parameters that have duplicate 'in' and 'name' properties\nconst deduplicateParameters = parameters => {\n  const paramsMap = {};\n  parameters.forEach(p => {\n    if (!paramsMap[p.in]) {\n      paramsMap[p.in] = {};\n    }\n    paramsMap[p.in][p.name] = p;\n  });\n  const dedupedParameters = [];\n  Object.keys(paramsMap).forEach(i => {\n    Object.keys(paramsMap[i]).forEach(p => {\n      dedupedParameters.push(paramsMap[i][p]);\n    });\n  });\n  return dedupedParameters;\n};\n\n// For stubbing in tests\nexport const self = {\n  buildRequest\n};\n\n// Execute request, with the given operationId and parameters\n// pathName/method or operationId is optional\nexport function execute({\n  http: userHttp,\n  fetch,\n  // This is legacy\n  spec,\n  operationId,\n  pathName,\n  method,\n  parameters,\n  securities,\n  ...extras\n}) {\n  // Provide default fetch implementation\n  const http = userHttp || fetch || stockHttp; // Default to _our_ http\n\n  if (pathName && method && !operationId) {\n    operationId = idFromPathMethodLegacy(pathName, method);\n  }\n  const request = self.buildRequest({\n    spec,\n    operationId,\n    parameters,\n    securities,\n    http,\n    ...extras\n  });\n  if (request.body && (isPlainObject(request.body) || Array.isArray(request.body))) {\n    request.body = JSON.stringify(request.body);\n  }\n\n  // Build request and execute it\n  return http(request);\n}\n\n// Build a request, which can be handled by the `http.js` implementation.\nexport function buildRequest(options) {\n  var _baseURL;\n  const {\n    spec,\n    operationId,\n    responseContentType,\n    scheme,\n    requestInterceptor,\n    responseInterceptor,\n    contextUrl,\n    userFetch,\n    server,\n    serverVariables,\n    http,\n    signal,\n    serverVariableEncoder\n  } = options;\n  let {\n    parameters,\n    parameterBuilders,\n    baseURL\n  } = options;\n  const specIsOAS3 = isOpenAPI3(spec);\n  if (!parameterBuilders) {\n    // user did not provide custom parameter builders\n    if (specIsOAS3) {\n      parameterBuilders = OAS3_PARAMETER_BUILDERS;\n    } else {\n      parameterBuilders = SWAGGER2_PARAMETER_BUILDERS;\n    }\n  }\n\n  // Set credentials with 'http.withCredentials' value\n  const credentials = http && http.withCredentials ? 'include' : 'same-origin';\n\n  // Base Template\n  let req = {\n    url: '',\n    credentials,\n    headers: {},\n    cookies: {}\n  };\n  if (signal) {\n    req.signal = signal;\n  }\n  if (requestInterceptor) {\n    req.requestInterceptor = requestInterceptor;\n  }\n  if (responseInterceptor) {\n    req.responseInterceptor = responseInterceptor;\n  }\n  if (userFetch) {\n    req.userFetch = userFetch;\n  }\n  const operationRaw = getOperationRaw(spec, operationId);\n  if (!operationRaw) {\n    throw new OperationNotFoundError(`Operation ${operationId} not found`);\n  }\n  const {\n    operation = {},\n    method,\n    pathName\n  } = operationRaw;\n  baseURL = (_baseURL = baseURL) !== null && _baseURL !== void 0 ? _baseURL : baseUrl({\n    spec,\n    scheme,\n    contextUrl,\n    server,\n    serverVariables,\n    pathName,\n    method,\n    serverVariableEncoder\n  });\n  req.url += baseURL;\n\n  // Mostly for testing\n  if (!operationId) {\n    // Not removing req.cookies causes testing issues and would\n    // change our interface, so we're always sure to remove it.\n    // See the same statement lower down in this function for\n    // more context.\n    delete req.cookies;\n    return req;\n  }\n  req.url += pathName; // Have not yet replaced the path parameters\n  req.method = `${method}`.toUpperCase();\n  parameters = parameters || {};\n  const path = spec.paths[pathName] || {};\n  if (responseContentType) {\n    req.headers.accept = responseContentType;\n  }\n  const combinedParameters = deduplicateParameters([].concat(arrayOrEmpty(operation.parameters)) // operation parameters\n  .concat(arrayOrEmpty(path.parameters))); // path parameters\n\n  // REVIEW: OAS3: have any key names or parameter shapes changed?\n  // Any new features that need to be plugged in here?\n\n  // Add values to request\n  combinedParameters.forEach(parameter => {\n    const builder = parameterBuilders[parameter.in];\n    let value;\n    if (parameter.in === 'body' && parameter.schema && parameter.schema.properties) {\n      value = parameters;\n    }\n    value = parameter && parameter.name && parameters[parameter.name];\n    if (typeof value === 'undefined') {\n      // check for `name-in` formatted key\n      value = parameter && parameter.name && parameters[`${parameter.in}.${parameter.name}`];\n    } else if (findParametersWithName(parameter.name, combinedParameters).length > 1) {\n      // value came from `parameters[parameter.name]`\n      // check to see if this is an ambiguous parameter\n      // eslint-disable-next-line no-console\n      console.warn(`Parameter '${parameter.name}' is ambiguous because the defined spec has more than one parameter with the name: '${parameter.name}' and the passed-in parameter values did not define an 'in' value.`);\n    }\n    if (value === null) {\n      return;\n    }\n    if (typeof parameter.default !== 'undefined' && typeof value === 'undefined') {\n      value = parameter.default;\n    }\n    if (typeof value === 'undefined' && parameter.required && !parameter.allowEmptyValue) {\n      throw new Error(`Required parameter ${parameter.name} is not provided`);\n    }\n    if (specIsOAS3 && parameter.schema && parameter.schema.type === 'object' && typeof value === 'string') {\n      try {\n        value = JSON.parse(value);\n      } catch (e) {\n        throw new Error('Could not parse object parameter value string as JSON');\n      }\n    }\n    if (builder) {\n      builder({\n        req,\n        parameter,\n        value,\n        operation,\n        spec,\n        baseURL\n      });\n    }\n  });\n\n  // Do version-specific tasks, then return those results.\n  const versionSpecificOptions = {\n    ...options,\n    operation\n  };\n  if (specIsOAS3) {\n    req = oas3BuildRequest(versionSpecificOptions, req);\n  } else {\n    // If not OAS3, then treat as Swagger2.\n    req = swagger2BuildRequest(versionSpecificOptions, req);\n  }\n\n  // If the cookie convenience object exists in our request,\n  // serialize its content and then delete the cookie object.\n  if (req.cookies && Object.keys(req.cookies).length) {\n    const cookieString = Object.keys(req.cookies).reduce((prev, cookieName) => {\n      const cookieValue = req.cookies[cookieName];\n      const prefix = prev ? '&' : '';\n      const stringified = cookie.serialize(cookieName, cookieValue);\n      return prev + prefix + stringified;\n    }, '');\n    req.headers.Cookie = cookieString;\n  }\n  if (req.cookies) {\n    // even if no cookies were defined, we need to remove\n    // the cookies key from our request, or many legacy\n    // tests will break.\n    delete req.cookies;\n  }\n\n  // Will add the query object into the URL, if it exists\n  // ... will also create a FormData instance, if multipart/form-data (eg: a file)\n  return serializeRequest(req);\n}\nconst stripNonAlpha = str => str ? str.replace(/\\W/g, '') : null;\n\n// be careful when modifying this! it is a publicly-exposed method.\nexport function baseUrl(obj) {\n  const specIsOAS3 = isOpenAPI3(obj.spec);\n  return specIsOAS3 ? oas3BaseUrl(obj) : swagger2BaseUrl(obj);\n}\nconst isNonEmptyServerList = value => Array.isArray(value) && value.length > 0;\nfunction oas3BaseUrl({\n  spec,\n  pathName,\n  method,\n  server,\n  contextUrl,\n  serverVariables = {},\n  serverVariableEncoder\n}) {\n  var _spec$paths, _spec$paths2;\n  let servers = [];\n  let selectedServerUrl = '';\n  let selectedServerObj;\n\n  // compute the servers (this will be taken care of by ApiDOM refrator plugins in future\n  const operationLevelServers = spec === null || spec === void 0 || (_spec$paths = spec.paths) === null || _spec$paths === void 0 || (_spec$paths = _spec$paths[pathName]) === null || _spec$paths === void 0 || (_spec$paths = _spec$paths[(method || '').toLowerCase()]) === null || _spec$paths === void 0 ? void 0 : _spec$paths.servers;\n  const pathItemLevelServers = spec === null || spec === void 0 || (_spec$paths2 = spec.paths) === null || _spec$paths2 === void 0 || (_spec$paths2 = _spec$paths2[pathName]) === null || _spec$paths2 === void 0 ? void 0 : _spec$paths2.servers;\n  const rootLevelServers = spec === null || spec === void 0 ? void 0 : spec.servers;\n  servers = isNonEmptyServerList(operationLevelServers) // eslint-disable-line no-nested-ternary\n  ? operationLevelServers : isNonEmptyServerList(pathItemLevelServers) // eslint-disable-line no-nested-ternary\n  ? pathItemLevelServers : isNonEmptyServerList(rootLevelServers) ? rootLevelServers : [DEFAULT_OPENAPI_3_SERVER];\n\n  // pick the first server that matches the server url\n  if (server) {\n    selectedServerObj = servers.find(srv => srv.url === server);\n    if (selectedServerObj) selectedServerUrl = server;\n  }\n\n  // default to the first server if we don't have one by now\n  if (!selectedServerUrl) {\n    [selectedServerObj] = servers;\n    selectedServerUrl = selectedServerObj.url;\n  }\n  if (testServerURLTemplate(selectedServerUrl, {\n    strict: true\n  })) {\n    const selectedServerVariables = Object.entries({\n      ...selectedServerObj.variables\n    }).reduce((acc, [serverVariableName, serverVariable]) => {\n      acc[serverVariableName] = serverVariable.default;\n      return acc;\n    }, {});\n    selectedServerUrl = substituteServerURLTemplate(selectedServerUrl, {\n      ...selectedServerVariables,\n      ...serverVariables\n    }, {\n      encoder: typeof serverVariableEncoder === 'function' ? serverVariableEncoder : identity\n    });\n  }\n  return buildOas3UrlWithContext(selectedServerUrl, contextUrl);\n}\nfunction buildOas3UrlWithContext(ourUrl = '', contextUrl = '') {\n  // relative server url should be resolved against contextUrl\n  const parsedUrl = ourUrl && contextUrl ? parseURIReference(url.resolve(contextUrl, ourUrl)) : parseURIReference(ourUrl);\n  const parsedContextUrl = parseURIReference(contextUrl);\n  const computedScheme = stripNonAlpha(parsedUrl.protocol) || stripNonAlpha(parsedContextUrl.protocol);\n  const computedHost = parsedUrl.host || parsedContextUrl.host;\n  const computedPath = parsedUrl.pathname;\n  let res;\n  if (computedScheme && computedHost) {\n    res = `${computedScheme}://${computedHost + computedPath}`;\n\n    // if last character is '/', trim it off\n  } else {\n    res = computedPath;\n  }\n  return res[res.length - 1] === '/' ? res.slice(0, -1) : res;\n}\n\n// Compose the baseUrl ( scheme + host + basePath )\nfunction swagger2BaseUrl({\n  spec,\n  scheme,\n  contextUrl = ''\n}) {\n  const parsedContextUrl = parseURIReference(contextUrl);\n  const firstSchemeInSpec = Array.isArray(spec.schemes) ? spec.schemes[0] : null;\n  const computedScheme = scheme || firstSchemeInSpec || stripNonAlpha(parsedContextUrl.protocol) || 'http';\n  const computedHost = spec.host || parsedContextUrl.host || '';\n  const computedPath = spec.basePath || '';\n  let res;\n  if (computedScheme && computedHost) {\n    // we have what we need for an absolute URL\n    res = `${computedScheme}://${computedHost + computedPath}`;\n  } else {\n    // if not, a relative URL will have to do\n    res = computedPath;\n  }\n\n  // If last character is '/', trim it off\n  return res[res.length - 1] === '/' ? res.slice(0, -1) : res;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}